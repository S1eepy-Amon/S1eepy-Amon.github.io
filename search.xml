<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Windows下使用GitHubPages托管博客换行问题</title>
    <url>/2023/11/24/BlogBuild/Bugfix/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在美美搭建完博客写了两篇文章之后，发现了一点小小的不对劲，这<code>hexo d</code>推到GithubPages上的博客[图1]和本地[图2]比起来丑了一点点…</p>
<p><img lazyload="" src="/images/loading.svg" data-src="/images/BlogBuild/Bugfix/bugfix1.png" alt="Bugfix-1"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="/images/BlogBuild/Bugfix/bugfix2.png" alt="Bugfix-2"></p>
<p>回忆了起来在<code>hexo d</code>时有提到一些和CRLF有关的warning，想起来了windows的换行符问题，大概率和它有关</p>
<h1 id="原理及解决"><a href="#原理及解决" class="headerlink" title="原理及解决"></a>原理及解决</h1><p>在windows系统中换行符是由<code>\r\n</code>即回车(<strong>C</strong>arriage<strong>R</strong>eturn)+换行(<strong>L</strong>ine<strong>F</strong>eed)组成的，而在linux和mac上只有一个<code>\n</code>字符就可以达到换行的效果</p>
<p>这就是为什么有的文件在windows上打开会变成一行，windows的文件放到linux上会多出来一个<code>^M</code></p>
<p>Git为windows提供了一个特别的设置来解决这个换行的问题，只需要在命令行执行下面命令就行，这样WindowsGit会自动将换行改为<code>LF</code></p>
<div class="highlight-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="code"><pre><span class="line">git config <span class="literal">--global</span> core.autocrlf=false</span><br></pre></td></tr></table></figure></div>

<p>另外有一个注意事项，在配置完毕后需要先删除博客根目录下<code>.deploy_git</code>这个隐藏目录，删除完毕后再执行<code>hexo clean, hexo g, hexo d</code>三步将博客推送过去</p>
]]></content>
      <categories>
        <category>BlogBuild</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
        <tag>bugfix</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo搭建博客</title>
    <url>/2023/11/12/BlogBuild/Hexo/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从大二学会搭博客起这已经是第三次迁移博客了，天天重启博客起始也没啥特别的原因，一方面是长时间没写博客了和前面衔接不上让我这强迫症癌感觉不太舒服，另一方面总是想着这次搭起来要把各方各面都做完善，其实现在想想做到完善哪有那么容易，还是好好培养自己写博客的习惯，慢慢把一个博客养好才是正道</p>
<p>其实以前想过自己写一些效果，但是后来发现这个学习成本还是有点高，时间上不太允许，所以就暂时长久的放入todolist中吧（乐）</p>
<h1 id="Hexo-Github-Pages-Redefine搭建博客"><a href="#Hexo-Github-Pages-Redefine搭建博客" class="headerlink" title="Hexo+Github Pages+Redefine搭建博客"></a>Hexo+Github Pages+Redefine搭建博客</h1><h2 id="为什么选Hexo"><a href="#为什么选Hexo" class="headerlink" title="为什么选Hexo"></a>为什么选Hexo</h2><p><del>当然是因为之前用的也是hexo啦</del></p>
<p>开个玩笑，选择搭静态博客主要是因为这些原因：一是写个博客没那么多需要交互的东西，静态搭起来就比较简单省事；二是静态博客比较安全，不容易被日，比较省心；三是操作管理比较简单，直接markdown就能写，GitHub就能托管（懒狗自然是最看重便捷性了）</p>
<p>至于选择Hexo倒没啥特别的原因，只是最开始s0uthwood师傅搭博客的时候用的hexo，跟着学的就是hexo罢了，其他如Hugo应该也与之类似，具体可以参考<a class="link" href="https://www.elegantcrazy.com/">优雅疯姿态的博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>Git主要用来进行托管我们的博客，当然自己买个域名开个云服务器然后扔到web目录下也是可以（但是哥们没钱），所以只能就这么用喽</p>
<p>Linux和Mac下安装git都不算困难，直接<code>apt install git</code>或者<code>brew install git</code>就可以</p>
<p>Windows下安装git需要到<a class="link" href="https://git-scm.com/download/win">官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>去安装，鼠标点点就行（怎么添加到环境变量就不讲了，搜搜就有）</p>
<p>在命令行输入<code>git</code>有回显就是装好了</p>
<h3 id="nodejs-npm"><a href="#nodejs-npm" class="headerlink" title="nodejs/npm"></a>nodejs/npm</h3><p>Hexo是基于nodejs开发的，因此系统上必须要有nodejs环境，npm是一个nodejs的包管理工具，个人理解类似于python的pip</p>
<p>Linux和Mac下同样简单<code>apt install nodejs npm</code>和<code>brew install nodejs npm</code></p>
<p>Windows下载nodejs还需要去<a class="link" href="https://nodejs.org/en/download">官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，下载自带npm</p>
<p>在命令行输入<code>node -v</code>和<code>npm -v</code>有回显就是装好了</p>
<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>有了npm，安装hexo就简单了，打开命令行<code>npm install hexo-cli -g</code>，再安装部署插件<code>npm install hexo-deployer-git --save</code></p>
<p>在命令行输入<code>hexo</code>有回显就是装好了</p>
<h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><h3 id="基础搭建"><a href="#基础搭建" class="headerlink" title="基础搭建"></a>基础搭建</h3><p>首先放一个<a class="link" href="https://hexo.io/zh-cn/docs/">官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>在这里，真遇到不会的可以去查一手</p>
<p>接下来详细介绍以下搭建的流程</p>
<p>第一步初始化一个博客的文件夹</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir hexo # 创建文件夹</span><br><span class="line">cd hexo    # 进入文件夹</span><br><span class="line">hexo init  # 把文件夹初始化为博客根目录</span><br></pre></td></tr></table></figure></div>

<p>嗯其实就没了，到这博客已经创建好了，剩下的就是配置和写博客的事情了，当然还是要预览一下看一眼我们的博客</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">hexo server # 或者直接`hexo s`</span><br></pre></td></tr></table></figure></div>

<p>该命令会在本地4000端口开启一个http服务，我们直接在浏览器访问<code>127.0.0.1:4000</code>即可预览我们的博客</p>
<h3 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a>主题选择</h3><p>经历了三次博客迁移，我发现大道至简，只要主题长得漂亮，文档写的清晰，同时还在积极更新，基本上就是一个很好的博客主题了，放一个<a class="link" href="https://hexo.io/themes/">hexo的主题页面 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>在这</p>
<p>这次我的选择是<a class="link" href="https://redefine-docs.ohevan.com/">Redefine <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>这个主题，文档清晰，在GitHub上提issue也很快有回复，推荐</p>
<p>总体来说主题的配置直接参考<a class="link" href="https://redefine-docs.ohevan.com/getting-started">主题官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>就行，没啥特别需要说的</p>
<h3 id="博客撰写"><a href="#博客撰写" class="headerlink" title="博客撰写"></a>博客撰写</h3><p>终于终于可以开始写博客了，虽然说起来这点比主题选择要重要一点，但是从配置流程上来说还是先配置主题再去写博客会好一些（毕竟不同主题对md的编写可能也存在一定区别）</p>
<p>先简单介绍以下写博客的流程，基本上就是 <code>hexo new</code> <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.181ex" role="img" focusable="false" viewBox="0 -511 1000 522"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g></g></g></svg></mjx-container> <code>hexo g</code> <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.181ex" role="img" focusable="false" viewBox="0 -511 1000 522"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g></g></g></svg></mjx-container> <code>hexo s</code> <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.181ex" role="img" focusable="false" viewBox="0 -511 1000 522"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g></g></g></svg></mjx-container> <code>hexo d</code> 下面挨个介绍几个命令</p>
<p>第一步是新建一篇文章，在博客根目录（之前mkdir的文件夹）下执行下面命令</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page --path &lt;Category&gt;/&lt;FileName&gt; "BlogTitle"</span><br></pre></td></tr></table></figure></div>

<p>新建的文章会出现的路径是<code>source/_posts/Category/NewBlog.md</code>，之后就可以去写博客了</p>
<p>写完博客之后需要将markdown生成静态html页面，在博客根目录执行命令如下</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure></div>

<p>执行后会生成出html页面，其位置在<code>public/&lt;year&gt;/&lt;month&gt;/&lt;day&gt;/&lt;category&gt;/&lt;filename&gt;</code>下，当然这个页面只是一个单纯的html，其他的css等配置同样在public目录下</p>
<p>第三步就是预览我们的博客，在博客根目录执行下面命令，进入<code>127.0.0.1:4000</code>即可看到我们博客的预览图</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure></div>

<p>最后，发布我们的博客到github pages（需要先把下面的GithubPages配置完成）</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure></div>

<h3 id="发布到Github-Pages"><a href="#发布到Github-Pages" class="headerlink" title="发布到Github Pages"></a>发布到Github Pages</h3><p>在发布之前，需要先对本机和git仓库做一些配置，主要是本机git配置、ssh密钥授权、git博客仓库创建三个部分</p>
<p>在本机装好git后，需要对本机的git进行简单配置，在命令行输入下面命令即可</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name "你的Github用户名"</span><br><span class="line">git config --global user.email "你的Github邮箱"</span><br></pre></td></tr></table></figure></div>

<p>然后进行ssh密钥授权，首先需要在本机生成ssh密钥</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa # 使用rsa加密算法生成密钥，一路回车</span><br><span class="line"></span><br><span class="line">cat ~/.ssh/id_rsa.pub # linux/mac下查看公钥文件</span><br><span class="line">type C:\Users\&lt;Username&gt;\.ssh\id_rsa.pub # Windows下查看公钥文件</span><br></pre></td></tr></table></figure></div>

<p>把 <code>cat/type</code> 的结果放到github上 <code>Settings</code> <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.181ex" role="img" focusable="false" viewBox="0 -511 1000 522"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g></g></g></svg></mjx-container> <code>SSH and GPG keys</code> <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.181ex" role="img" focusable="false" viewBox="0 -511 1000 522"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g></g></g></svg></mjx-container> <code>New SSH Key</code> 即可，这样就可以直接推送到github页面而不需要输入口令了</p>
<p>最后需要在git新建一个存放静态博客的仓库，仓库名为 <code>&lt;GithubUsername&gt;.github.io</code>，并在自己博客根目录下找到 <code>_config.yml</code>进行配置，配置如下</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:你的用户名/你的用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></div>

<p>至此，可以开始自己快乐的博客撰写之旅了</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>完结撒花，这篇博客总体来说偏向于记录一下流程，很多细节上比较简略，也不太清楚其他朋友们看起来怎么样，如果你有幸读到这篇博客，那么可以在下面评论区留下你宝贵的观后感~</p>
<p>本来搭完博客的第一件事就是简单记录一下，结果硬是拖了一周才写完这篇博客，希望后续博客可以记得时常更新（笔记存货还不少，反正慢慢复习知识点吧）</p>
]]></content>
      <categories>
        <category>BlogBuild</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下环境搭建记录</title>
    <url>/2023/11/15/WindowsEnv/WindowsEnvBuild/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录一下自己的windows环境搭建和美化的过程，后续可能还会继续添加内容</p>
<h1 id="Windows下工具"><a href="#Windows下工具" class="headerlink" title="Windows下工具"></a>Windows下工具</h1><p>开发工具：</p>
<ul>
<li><a class="link" href="https://code.visualstudio.com/">VSCode<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link" href="https://www.jetbrains.com/idea/">IDEA<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link" href="https://nodejs.org/en">Nodejs<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link" href="https://git-scm.com/">Git<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link" href="https://hexo.io/zh-cn/">Hexo<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li>VMWare<ul>
<li><a class="link" href="https://www.kali.org/">Kali Linux<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li>Windows 10</li>
</ul>
</li>
</ul>
<p>常用工具：</p>
<ul>
<li><a class="link" href="https://www.google.com/chrome/">Chrome<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link" href="https://www.microsoft.com/zh-cn/edge?form=MA13FJ">Edge<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li>Clash</li>
<li><a class="link" href="https://obsidian.md/">Obsidian<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link" href="https://www.bandisoft.com/bandizip/">Bandzip<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<p>安全工具：</p>
<ul>
<li>CobaltStrike</li>
<li>ida</li>
<li><a class="link" href="https://www.wireshark.org/">Wireshark<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li>BurpSuite</li>
</ul>
<p>VSCode插件:</p>
<ul>
<li>C/C++ Themes</li>
<li>One Dark Pro</li>
<li>Remote SSH</li>
<li>background-cover</li>
<li>GitHub Copilot</li>
<li>clangd</li>
</ul>
<p>Edge插件:</p>
<ul>
<li>划词翻译</li>
<li>ADGuard</li>
<li>Proxy SwitchyOmega</li>
</ul>
<h1 id="Beautify"><a href="#Beautify" class="headerlink" title="Beautify"></a>Beautify</h1><p>装工具也就图一乐，真开心还得看美化的过程，每次看着自己的电脑漂亮起来都是一种享受</p>
<h2 id="Oh-My-Posh"><a href="#Oh-My-Posh" class="headerlink" title="Oh-My-Posh"></a>Oh-My-Posh</h2><p>首先贴一个<a class="link" href="https://ohmyposh.dev/">官网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>在这</p>
<p>Oh-My-Posh听名字就和Oh-My-Zsh一样，是个用于美化终端的工具，只不过我们今天的主角是用于美化Powershell的</p>
<p>自从Windows 11以来，Windows Terminal就集成到了windows系统中，比起以前那个黑框框和蓝框框已经好看了不少，但是相较之下还是有点单调，这时就需要我们的Oh-My-Posh来进行美化了</p>
<p>我个人的Oh-My-Posh美化过程分为三步，安装设置Oh-My-Posh，更换随机主题，更换字体和背景</p>
<p>首先安装Oh-My-Posh，有两种方法，一种是直接上Microsoft Store上去下载，鼠标点点就行，第二种是powershell命令行下载，命令如下（PS: 更新命令与之相同）</p>
<div class="code-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> Bypass <span class="literal">-Scope</span> <span class="keyword">Process</span> <span class="literal">-Force</span>; <span class="built_in">Invoke-Expression</span> ((<span class="built_in">New-Object</span> System.Net.WebClient).DownloadString(<span class="string">'https://ohmyposh.dev/install.ps1'</span>))</span><br></pre></td></tr></table></figure></div>

<p>第二步需要让我们的terminal打开时自动启动Oh-My-Posh，并设置一个随机的主题。首先查看我们的powershell设置，在powershell中输入<code>$profile</code>回车就能找到设置的路径，在这个ps1文件里添加如下内容完成设置</p>
<div class="code-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$theme</span> = <span class="built_in">Get-ChildItem</span> <span class="variable">$env:UserProfile</span>\\AppData\\Local\\Programs\\oh<span class="literal">-my-posh</span>\\themes\\ | <span class="built_in">Get-Random</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello! today's lucky theme is: <span class="variable">$theme</span> :)"</span></span><br><span class="line"><span class="built_in">oh</span><span class="literal">-my-posh</span> <span class="literal">--init</span> <span class="literal">--shell</span> pwsh <span class="literal">--config</span> <span class="variable">$theme</span>.FullName | <span class="built_in">Invoke-Expression</span></span><br></pre></td></tr></table></figure></div>

<p>第三步换字体和背景，<a class="link" href="https://www.nerdfonts.com/">字体下载处<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，个人推荐JetBrains的<a class="link" href="https://www.programmingfonts.org/#jetbrainsmono">JetBrainsMono Nerd Font<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，因为很多其他字体会加载不出来图案</p>
<p>下载完字体后打开windows的<code>设置</code> <code>个性化</code> <code>字体</code>把下载的字体导入，接下来就是让windows terminal识别这个字体（顺便把背景也设置了），首先打开windows terminal的配置文件（开个windows terminal摁下<code>Ctrl+Shift+,</code>），找到如下配置进行对应设置即可</p>
<div class="code-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">"profiles"</span><span class="punctuation">:</span> </span><br><span class="line">    <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"defaults"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">            <span class="attr">"useAcrylic"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> </span><br><span class="line">            <span class="attr">"acrylicOpacity"</span><span class="punctuation">:</span> <span class="number">0.2</span><span class="punctuation">,</span> <span class="comment">// 不透明度</span></span><br><span class="line">            <span class="attr">"backgroundImage"</span><span class="punctuation">:</span> <span class="string">"Path\\image.png"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"backgroundImageOpacity"</span><span class="punctuation">:</span> <span class="number">0.4</span><span class="punctuation">,</span> <span class="comment">// 背景图片的不透明度</span></span><br><span class="line">            <span class="attr">"font"</span><span class="punctuation">:</span> </span><br><span class="line">            <span class="punctuation">{</span></span><br><span class="line">                <span class="attr">"face"</span><span class="punctuation">:</span> <span class="string">"JetBrainsMono Nerd Font"</span></span><br><span class="line">            <span class="punctuation">}</span></span><br><span class="line">        <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">}</span></span><br></pre></td></tr></table></figure></div>

<p>贴个效果图在这</p>
<p><img lazyload="" src="/images/loading.svg" data-src="/images/WindowsEnv/WindowsEnvBuild/Terminal.png" alt="Terminal"></p>
<h1 id="VSCode插件设置"><a href="#VSCode插件设置" class="headerlink" title="VSCode插件设置"></a>VSCode插件设置</h1><h2 id="clangd的代码跳转"><a href="#clangd的代码跳转" class="headerlink" title="clangd的代码跳转"></a>clangd的代码跳转</h2><p>在使用C/C++的时候遇到了代码跳转以及补全功能不对劲的问题，因此后续采用clangd的代码跳转和补全功能，由于C/C++与clangd存在冲突，因此需要禁用C/C++的所有相关插件</p>
<blockquote>
<p>C/C++有时会遇到跳转很慢的问题，只需要将<code>C_Cpp.intelliSenseEngine</code>设置为<code>Tag Parser</code>即可</p>
</blockquote>
<p>clangd的代码补全比较好用，而跳转需要生成对应的compile_commands.json文件，可以通过compiledb在编译时自动生成该配置文件</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">pip install compiledb</span><br></pre></td></tr></table></figure></div>

<p>使用compiledb生成compile_commands.json有多种方式，主要介绍以下几种</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">make时生成</span></span><br><span class="line">compiledb make xxx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">单独生成compile_commands.json而不编译</span></span><br><span class="line">compiledb -n make xxx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmake方式，在CMakeLists.txt中添加</span></span><br><span class="line">set(CMAKE_EXPORT_COMPILECOMMANDS ON)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">针对Linux内核代码，使用Linux内核自带脚本生成</span></span><br><span class="line">./scripts/clang-tools/gen_compile_commands.py</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>EnvBuild</category>
      </categories>
      <tags>
        <tag>WindowsEnv</tag>
        <tag>EnvBeautify</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Wireguard搭建全流量代理</title>
    <url>/2024/09/08/Proxy/Wireguard/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要介绍一下之前在Ubuntu和Windows上搭建Wireguard组建内网代理的流程。（本文是已经完成配置后重新编写，流程基本靠回忆，没有再进行第二次测试，若有任何问题可以留言让我更改错误）</p>
<p>来段GPT介绍：Wireguard是一种简单、高效、现代化的虚拟专用网络（VPN）协议，旨在为用户提供高速、简洁且安全的网络通信方式。WireGuard 使用了现代、强大的加密算法来确保数据传输的安全性。这些算法被选择是因为它们在性能和安全性上达到了很好的平衡，相比于传统 VPN它具有更好的性能。</p>
<p>搭建环境：</p>
<ul>
<li>一台Ubuntu作为服务端（中继节点）</li>
<li>一台Windows作为客户端（Peer节点）</li>
</ul>
<blockquote>
<p>Wireguard协议中，中继节点使用一台服务器来整合所有对等节点的流量并将其路由到互联网，从而实现虚拟专用网络（VPN）连接。对等节点是指使用 WireGuard 协议的客户端设备，它们之间可以直接通信，而无需通过中继节点。对等节点可以是任何支持 WireGuard 协议的设备，例如计算机、手机、路由器等等。在 WireGuard 中，中继节点和对等节点的配置方式也略有不同。<code>简单来说可以将中继节点理解为服务端，Peer节点理解为客户端</code></p>
</blockquote>
<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="中继节点配置"><a href="#中继节点配置" class="headerlink" title="中继节点配置"></a>中继节点配置</h2><h3 id="确保关闭ufw"><a href="#确保关闭ufw" class="headerlink" title="确保关闭ufw"></a>确保关闭ufw</h3><p>由于本人是在ubuntu上20.04上进行中继节点的配置，因此需要首先关闭ubuntu自带的防火墙ufw</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ufw disable</span><br></pre></td></tr></table></figure></div>

<h3 id="安装Wireguard"><a href="#安装Wireguard" class="headerlink" title="安装Wireguard"></a>安装Wireguard</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install wireguard</span><br></pre></td></tr></table></figure></div>

<h3 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir /etc/wireguard</span><br><span class="line">cd /etc/wireguard</span><br><span class="line">wg genkey | tee privatekey</span><br><span class="line">wg pubkey &lt; privatekey &gt; publickey</span><br></pre></td></tr></table></figure></div>

<p>中继节点生成的私钥会保存在<code>/etc/wireguard/privatekey</code>中，公钥为<code>/etc/wireguard/publickey</code></p>
<h3 id="编写Wireguard配置"><a href="#编写Wireguard配置" class="headerlink" title="编写Wireguard配置"></a>编写Wireguard配置</h3><p>配置文件可以放置在任何路径下，但是启动时需要指定绝对路径，本人在此放置的配置文件名为<code>/etc/wireguard/wg0.conf</code>，其中wg0是之后会新建的网卡设备名</p>
<p>文件内容如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Interface]</span><br><span class="line">Address = 192.168.105.1/24</span><br><span class="line">SaveConfig = true</span><br><span class="line">PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line">PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line">ListenPort = 53</span><br><span class="line">PrivateKey = {中继节点的私钥，即刚才生成的私钥}</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意事项1：上述文件大部分都可以自定义，但是ListenPort这里如果要进行全流量代理，则必须设置为53，而设置53时会出现和Ubuntu自带的dns解析冲突，需要简单解决一下</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭ubuntu自带的dns解析</span></span><br><span class="line">systemctl stop systemd-resolved</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改dns解析服务器</span></span><br><span class="line">vim /etc/resolved.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将/etc/resolved.conf的解析地址只保留一行 namerserver 114.114.114.114，其余全部注释</span></span><br></pre></td></tr></table></figure></div>
</blockquote>
<blockquote>
<p>注意事项2：文件中的eth0网卡需要改为自己的网卡，<code>ifconfig</code>或者<code>ip -o -4 route show to default | awk '{print $5}'</code>都可以查看</p>
</blockquote>
<p>之后还会对该文件添加Peer节点，但是暂时先写到这里，需要添加时再回来</p>
<h3 id="配置内核参数"><a href="#配置内核参数" class="headerlink" title="配置内核参数"></a>配置内核参数</h3><p>为了让 WireGuard 中继节点转发数据包，需要设置内核参数 net.ipv4.ip_forward=1 和 net.ipv4.conf.all.proxy_arp=1。其中，net.ipv4.ip_forward=1 允许 Linux 内核将数据包从一个网络接口转发到另一个网络接口，net.ipv4.conf.all.proxy_arp=1 则允许 Linux 内核在本地网络中拦截 ARP 请求并向请求方提供本地主机的 MAC 地址，从而实现数据包的转发。流程如下</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/sysctl.conf</span><br></pre></td></tr></table></figure></div>

<p>文件内查找如下内容进行修改</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">net.ipv4.ip_forward=1</span><br><span class="line">net.ipv4.conf.all.proxy_arp = 1</span><br></pre></td></tr></table></figure></div>

<p>生效配置</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sysctl -p /etc/sysctl.conf</span><br></pre></td></tr></table></figure></div>

<h3 id="Wireguard，启动！"><a href="#Wireguard，启动！" class="headerlink" title="Wireguard，启动！"></a>Wireguard，启动！</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">// 执行命令</span><br><span class="line">sudo wg-quick up wg0</span><br><span class="line">// 输出结果</span><br><span class="line"><span class="meta prompt_">[#</span><span class="language-bash">] ip <span class="built_in">link</span> add wg0 <span class="built_in">type</span> wireguard</span></span><br><span class="line"><span class="meta prompt_">[#</span><span class="language-bash">] wg setconf wg0 /dev/fd/63</span></span><br><span class="line"><span class="meta prompt_">[#</span><span class="language-bash">] ip -4 address add 192.168.100.5/24 dev wg0</span></span><br><span class="line"><span class="meta prompt_">[#</span><span class="language-bash">] ip <span class="built_in">link</span> <span class="built_in">set</span> mtu 1420 up dev wg0</span></span><br><span class="line"><span class="meta prompt_">[#</span><span class="language-bash">] iptables -A FORWARD -i wg0 -j ACCEPT; iptables -A FORWARD -o wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span></span><br></pre></td></tr></table></figure></div>

<p>可以通过如下命令检测wireguard的状态</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">// 执行命令</span><br><span class="line">sudo wg show wg0</span><br><span class="line">// 输出结果</span><br><span class="line">interface: wg0</span><br><span class="line">  public key: {你的公钥}</span><br><span class="line">  private key: (hidden)</span><br><span class="line">  listening port: 51820</span><br><span class="line">  fwmark: 0xca6c</span><br></pre></td></tr></table></figure></div>

<h3 id="设置Wireguard开机自启"><a href="#设置Wireguard开机自启" class="headerlink" title="设置Wireguard开机自启"></a>设置Wireguard开机自启</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable wg-quick@wg0.service</span><br></pre></td></tr></table></figure></div>

<h2 id="Peer节点配置"><a href="#Peer节点配置" class="headerlink" title="Peer节点配置"></a>Peer节点配置</h2><p>之后本人是在Windows上配置的Peer节点，因此后面命令均在Windows上运行，若要在Ubuntu等Linux机器上运行，可参考下方参考文献的方案（本质区别不大）</p>
<h3 id="在Windows上安装Wireguard"><a href="#在Windows上安装Wireguard" class="headerlink" title="在Windows上安装Wireguard"></a>在Windows上安装Wireguard</h3><p>Windows安装十分简单，直接去<a class="link" href="https://www.wireguard.com/install/">官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>下载就好，安装完毕后命令行应该也会自动添加进来（我不记得是否有环境变量这一步了，似乎安装时会自动添加到环境变量，如果没有手动加一下就行）</p>
<p>在powershell输入<code>wg -h</code>可以查看安装信息，会提示<code>Available subcommands</code></p>
<h3 id="Peer节点生成密钥对并配置"><a href="#Peer节点生成密钥对并配置" class="headerlink" title="Peer节点生成密钥对并配置"></a>Peer节点生成密钥对并配置</h3><div class="highlight-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="code"><pre><span class="line">mkdir C:\\User\\[<span class="type">Username</span>]\\.wireguard</span><br><span class="line"><span class="built_in">cd</span> C:\\User\\[<span class="type">Username</span>]\\.wireguard</span><br><span class="line">wg genkey | <span class="built_in">tee</span> privatekey</span><br><span class="line">wg pubkey &lt; privatekey &gt; publickey</span><br></pre></td></tr></table></figure></div>

<p>生成的私钥将保存在 <code>C:\\User\\[Username]\\.wireguard\\privatekey</code> 中，公钥将保存在 <code>C:\\User\\[Username]\\.wireguard\\publickey</code> 中。</p>
<h3 id="编写Wireguard配置-1"><a href="#编写Wireguard配置-1" class="headerlink" title="编写Wireguard配置"></a>编写Wireguard配置</h3><p>同样随便找个路径写个<code>wg0.conf</code>，内容如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Interface]</span><br><span class="line">PrivateKey = {Peer节点的私钥}</span><br><span class="line">Address = 192.168.105.2/24</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line">PublicKey = {中继节点的公钥}</span><br><span class="line">AllowedIPs = 0.0.0.0/1, 128.0.0.0/1</span><br><span class="line">Endpoint = {中继节点的公网IP}:53</span><br><span class="line">PersistentKeepalive = 21</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>这里需要注意的是Peer下的AllowIPs，设置这两个IP的意思是进行全流量代理。另外注意Endpoint的端口是53</p>
</blockquote>
<p>完成编写后直接打开Wireguard软件导入隧道即可，Windows下点点就行，就不做演示了（懒得截图是这样的）</p>
<h3 id="将Peer节点添加到中继节点"><a href="#将Peer节点添加到中继节点" class="headerlink" title="将Peer节点添加到中继节点"></a>将Peer节点添加到中继节点</h3><p>现在又要回到中继节点Ubuntu，将我们刚刚生成的公钥添加到中继节点上，在Ubuntu上<code>sudo vim /etc/wireguard/wg0.conf</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Interface]</span><br><span class="line">Address = 192.168.105.1/24</span><br><span class="line">SaveConfig = true</span><br><span class="line">PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o ens3 -j MASQUERADE</span><br><span class="line">PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o ens3 -j MASQUERADE</span><br><span class="line">ListenPort = 53</span><br><span class="line">PrivateKey = {中继节点的私钥}</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line">PublicKey = {Peer节点的公钥}</span><br><span class="line">AllowedIPs = 192.168.105.2/32</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意编辑的时候记得先在ubuntu上关闭wireguard，运行<code>sudo wg-quick down wg0</code>，不然正运行时写入不会保存进去</p>
</blockquote>
<p>编辑完毕后重新启动<code>sudo wg-quick up wg0</code>，然后使用<code>sudo wg show</code>查看状态，确保Peer节点已经添加进入</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface: wg0</span><br><span class="line">  public key: {中继节点公钥}</span><br><span class="line">  private key: (hidden)</span><br><span class="line">  listening port: 51820</span><br><span class="line">  fwmark: 0xca6c</span><br><span class="line"></span><br><span class="line">peer: {Peer 节点公钥}</span><br><span class="line">  endpoint: {Peer 节点公网IP}:64886</span><br><span class="line">  allowed ips: 192.168.100.2/32</span><br><span class="line">  latest handshake: 1 minute, 44 seconds ago</span><br><span class="line">  transfer: 40.12 KiB received, 10.00 KiB sent</span><br></pre></td></tr></table></figure></div>

<h3 id="最终测试"><a href="#最终测试" class="headerlink" title="最终测试"></a>最终测试</h3><p>在Windows上也点击连接后，若能二者能互相通过<code>192.168.105.*</code>进行<code>ping</code>即说明连接成功，然后就是根据一些查看IP地址的工具（比如在线网页或者学校的流量网关查看IP）进行测试是否进行了全流量代理</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a class="link" href="https://yaoyao.io/posts/using-wireguard-on-ubuntu">如何在 Ubuntu 20 04 运行 WireGuard | YaoYao’s Blog <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>Proxy</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
        <tag>Wireguard</tag>
      </tags>
  </entry>
</search>
